<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GW</title>
    <style>
        body {
            background-color: #111;
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #genomePlot {
            display: block;
            margin-bottom: 10px;
            border: 1px solid #444;
        }
        #commandForm {
            margin-bottom: 0;
            display: inline-flex;
            align-items: center;
        }
        .nav-buttons {
            display: inline-flex;
            gap: 10px;
            margin-left: 15px;
            align-items: center;
        }
        .command-nav-container {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            height: 40px;
        }
        .nav-button {
            width: 30px;
            height: 30px;
            font-size: 20px;
            line-height: 26px;
            cursor: pointer;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .nav-button:hover {
            background-color: #444;
        }
        #btn-zoom-in, #btn-zoom-out {
            font-weight: bold;
            font-size: 18px;
        }
        .clear-output {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 5px;
            height: 30px;
            display: flex;
            align-items: center;
            margin-left: 15px;
        }
        .clear-output:hover {
            background-color: #444;
        }
        input[type="text"] {
            padding: 6px 8px;
            height: 18px;
            width: 300px;
            background-color: #222;
            color: white;
            border: 1px solid #444;
            box-sizing: content-box;
        }
        input[type="submit"] {
            padding: 6px 15px;
            height: 30px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            cursor: pointer;
            box-sizing: border-box;
        }
        input[type="submit"]:hover {
            background-color: #444;
        }
        #outputContainer {
            flex: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #outputBox {
            width: 100%;
            flex: 1;
            background-color: #111;
            color: #e0e0e0;
            font-family: 'Consolas', 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            line-height: 1.4;
            border: 1px solid #444;
            padding: 10px;
            padding-bottom: 20px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            tab-size: 4;
            -moz-tab-size: 4;
            box-sizing: border-box;
            margin-bottom: 10px;
            max-height: calc(100% - 10px);
        }
    </style>
</head>
<body>
    <canvas id="genomePlot" width="950" height="300"></canvas>

    <div class="command-nav-container">
        <form id="commandForm">
            <input type="text" name="user_input" id="user_input" placeholder="Enter GW command here" value="chr1" spellcheck="false" autocomplete="off">
            <input type="submit" value="Submit">
        </form>

        <div class="nav-buttons">
            <button class="nav-button" id="btn-left">←</button>
            <button class="nav-button" id="btn-right">→</button>
            <button class="nav-button" id="btn-up">↑</button>
            <button class="nav-button" id="btn-down">↓</button>
            <button class="nav-button" id="btn-zoom-in">+</button>
            <button class="nav-button" id="btn-zoom-out">−</button>
            <button class="clear-output" id="clearOutput">Clear Log</button>
        </div>
    </div>

    <!-- Output Container -->
    <div id="outputContainer">
        <div id="outputBox"></div>
    </div>

    <script>
        // Calculate canvas dimensions accounting for device pixel ratio
        function getCanvasDimensions() {
            // Get device pixel ratio
            const dpr = window.devicePixelRatio || 1;

            // Visual dimensions (CSS pixels)
            const cssWidth = Math.max(window.innerWidth - 20, 300);
            const cssHeight = Math.max(Math.floor(window.innerHeight * 0.6), 300);

            // Physical dimensions (actual pixels, accounting for high DPI)
            const physicalWidth = Math.round(cssWidth * dpr);
            const physicalHeight = Math.round(cssHeight * dpr);

            return {
                cssWidth,           // Size for display (CSS)
                cssHeight,          // Size for display (CSS)
                physicalWidth,      // Actual pixel dimensions for rendering
                physicalHeight,     // Actual pixel dimensions for rendering
                dpr                 // Device pixel ratio
            };
        }

        // Function to ensure output box takes up remaining space
        function adjustOutputBoxHeight() {
            const genomePlot = document.getElementById('genomePlot');
            const commandNav = document.querySelector('.command-nav-container');

            // Calculate available height
            const windowHeight = window.innerHeight;
            const usedHeight = genomePlot.offsetHeight + commandNav.offsetHeight + 40; // 40px for margins/padding

            // Set the outputContainer to use the remaining space
            const outputContainer = document.getElementById('outputContainer');
            outputContainer.style.height = (windowHeight - usedHeight) + 'px';
        }

        document.getElementById('commandForm').onsubmit = function(event) {
            event.preventDefault();
            var inputElement = document.getElementById('user_input');
            var userInput = inputElement.value;

            fetch('/submit', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: 'user_input=' + encodeURIComponent(userInput)
            })
            .then(response => response.json())
            .then(data => {
                updateCanvas(data.image);
                // Clear the input after successful submission
                inputElement.value = '';
                // Fetch latest output after command execution
                fetchOutput();
            })
            .catch(error => console.error('Error:', error));
        };

        // Setup navigation buttons
        document.getElementById('btn-left').addEventListener('click', function() {
            sendKeyToServer('ArrowLeft');
        });
        document.getElementById('btn-right').addEventListener('click', function() {
            sendKeyToServer('ArrowRight');
        });
        document.getElementById('btn-zoom-in').addEventListener('click', function() {
            sendKeyToServer('ArrowUp');
        });
        document.getElementById('btn-zoom-out').addEventListener('click', function() {
            sendKeyToServer('ArrowDown');
        });
        document.getElementById('btn-up').addEventListener('click', function() {
            sendKeyToServer('PageUp');
        });
        document.getElementById('btn-down').addEventListener('click', function() {
            sendKeyToServer('PageDown');
        });

        // Setup clear output button
        document.getElementById('clearOutput').addEventListener('click', function() {
            // Clear the server-side log
            fetch('/clear-output', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('outputBox').textContent = '';
                }
            })
            .catch(error => console.error('Error clearing output:', error));
        });

        function resizeCanvas() {
            const canvas = document.getElementById('genomePlot');
            const dimensions = getCanvasDimensions();

            // Set CSS dimensions for display size
            canvas.style.width = dimensions.cssWidth + 'px';
            canvas.style.height = dimensions.cssHeight + 'px';

            // Tell the server to generate a high-resolution image
            sendCanvasSizeToServer(dimensions.physicalWidth, dimensions.physicalHeight);

            console.log(`Canvas display size: ${dimensions.cssWidth}x${dimensions.cssHeight},
                         Physical size: ${dimensions.physicalWidth}x${dimensions.physicalHeight},
                         DPR: ${dimensions.dpr}`);

            // Also adjust the output box height
            adjustOutputBoxHeight();
        }

        function loadImage() {
            // Add cache-busting parameter with timestamp
            fetch('/display_image?nocache=' + new Date().getTime())
                .then(response => response.json())
                .then(data => {
                    updateCanvas(data.image);
                    fetchOutput();
                })
                .catch(error => console.error('Error loading initial image:', error));
        }

        function updateCanvas(imageData) {
            const canvas = document.getElementById('genomePlot');

            if (!imageData) {
                console.log("No image data provided to updateCanvas.");
                loadImage(); // Try to load image if none provided
                return;
            }

            const img = new Image();
            img.onload = function() {
                // Set canvas internal dimensions to match image size
                canvas.width = img.width;
                canvas.height = img.height;

                // Get context and disable image smoothing
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.mozImageSmoothingEnabled = false;
                ctx.webkitImageSmoothingEnabled = false;
                ctx.msImageSmoothingEnabled = false;

                // Clear and draw the image at its native size
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);

                console.log(`High-resolution image rendered: ${img.width}x${img.height}`);

                // Adjust output box height after canvas is loaded
                adjustOutputBoxHeight();
            };

            img.onerror = function(e) {
                console.error("Error loading image onto canvas:", e);
            };

            img.src = imageData;
        }

        // Variables to store previous output length to prevent scroll jumping
        let previousOutputLength = 0;
        let userHasScrolled = false;

        // Function to fetch and update the output box with better scroll handling
        function fetchOutput() {
            // Save current scroll position and check if user has scrolled up
            const outputBox = document.getElementById('outputBox');
            const isScrolledToBottom = (outputBox.scrollHeight - outputBox.clientHeight) <= (outputBox.scrollTop + 5);

            fetch('/get-output')
                .then(response => response.json())
                .then(data => {
                    // Check if content actually changed before updating
                    if (data.output.length !== previousOutputLength) {
                        outputBox.textContent = data.output;
                        previousOutputLength = data.output.length;

                        // Only auto-scroll if user was already at the bottom
                        if (isScrolledToBottom) {
                            outputBox.scrollTop = outputBox.scrollHeight;
                        }
                    }
                })
                .catch(error => console.error('Error fetching output:', error));
        }

        // Manual scroll detection to control auto-scrolling behavior
        document.getElementById('outputBox').addEventListener('scroll', function() {
            const outputBox = document.getElementById('outputBox');
            userHasScrolled = true;

            // Check if scrolled to bottom
            if ((outputBox.scrollHeight - outputBox.clientHeight) <= (outputBox.scrollTop + 5)) {
                userHasScrolled = false;
            }
        });

        // Set up mouse event handling for the canvas
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('genomePlot');

            // Mouse click handler
            canvas.addEventListener('mousedown', function(event) {
                handleMouseEvent(event, event.button === 0 ? 'left' : 'right');
            });

            // Mouse wheel handler
            canvas.addEventListener('wheel', function(event) {
                event.preventDefault(); // Prevent page scrolling
                handleMouseEvent(event, event.deltaY > 0 ? 'wheel_down' : 'wheel_up');
            });

            // Helper function to calculate canvas coordinates and send to server
            function handleMouseEvent(event, button) {
                // Get canvas and its dimensions
                const canvas = event.target;
                const rect = canvas.getBoundingClientRect();

                // Calculate the device pixel ratio for high-DPI displays
                const dpr = window.devicePixelRatio || 1;

                // Calculate mouse position relative to canvas in CSS pixels
                const cssX = event.clientX - rect.left;
                const cssY = event.clientY - rect.top;

                // Convert to canvas coordinates using the ratio of actual canvas dimensions to display dimensions
                const canvasX = Math.round(cssX * (canvas.width / rect.width));
                const canvasY = Math.round(cssY * (canvas.height / rect.height));

                console.log(`Mouse ${button} at canvas coordinates: ${canvasX}, ${canvasY}`);

                // Send to server
                fetch('/mouse-event', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        x: canvasX,
                        y: canvasY,
                        button: button,
                        nocache: new Date().getTime() // Add cache busting parameter
                    })
                })
                .then(response => response.json())
                .then(data => {
                    updateCanvas(data.image);
                    // Fetch latest output after mouse event
                    fetchOutput();
                })
                .catch(error => console.error('Error sending mouse event:', error));
            }
        });

        // Set up a polling mechanism to refresh the output periodically
        let outputPollInterval;
        function startOutputPolling() {
            // Poll at a slower rate (1 second) to reduce jitter
            outputPollInterval = setInterval(fetchOutput, 1000);
        }

        // Handle canvas resizing and initial load
        document.addEventListener('DOMContentLoaded', function() {
            console.log(`Device Pixel Ratio: ${window.devicePixelRatio}`);

            // Apply resize and fetch initial image
            resizeCanvas();

            // Start polling for output updates
            startOutputPolling();

            // Add debounce to avoid too many resize events
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function() {
                    resizeCanvas();
                }, 250); // Wait 250ms after resize finishes
            });

            // Forward keystrokes to command box (except arrow keys)
            document.addEventListener('keydown', function(event) {
                const arrowKeys = ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"];

                // If it's an arrow key, prevent default behavior (scrolling)
                if (arrowKeys.includes(event.key)) {
                    event.preventDefault();
                    sendKeyToServer(event.key);
                    return;
                }

                // If it's not an arrow key and not a control combo
                if (!event.ctrlKey && !event.metaKey && !event.altKey) {
                    // Get the command input box
                    const commandInput = document.getElementById('user_input');

                    // If we're not already focused on the input or a text element
                    if (document.activeElement !== commandInput &&
                        !(document.activeElement.tagName === 'INPUT' && document.activeElement.type === 'text') &&
                        document.activeElement.tagName !== 'TEXTAREA') {

                        // Focus the input
                        commandInput.focus();
                    }
                }
            });
        });

        function sendCanvasSizeToServer(width, height) {
            // Get the device pixel ratio
            const dpr = window.devicePixelRatio || 1;

            fetch('/update-canvas-size', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    width: width,
                    height: height,
                    dpr: dpr
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server updated canvas size:', data);
                loadImage(); // Load image after size update
            })
            .catch(error => console.error('Error sending canvas size:', error));
        }

        function sendKeyToServer(key) {
            fetch('/key-event', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ key: key })
            })
            .then(response => response.json())
            .then(data => {
                if (data.image && data.image !== '') {
                    updateCanvas(data.image);
                    // After key press, fetch the latest output
                    fetchOutput();
                }
            })
            .catch(error => console.error('Error:', error));
        }

        let lastTimeKeyPressed = 0;
        const throttleDuration = 100; // Minimum time between events in milliseconds

        // This is managed by the keydown event handler above that also prevents default
    </script>
</body>
</html>